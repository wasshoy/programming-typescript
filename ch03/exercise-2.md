# 2. なぜエラーがスローされるのか
## 🙆‍♂️ a.
```ts
let i: 3 = 3
i = 4 // エラー
```
i はリテラル型3 に指定されているので，letで宣言しようと**リテラル型4の4に**変更することは出来ない．


## 🙍‍♂️ b.
```ts
let j = [1, 2, 3]
j.push(4)
j.push('5') // エラー
```
j は宣言の時点でnumber[]と型推論される．
そのため，~~string~~ **リテラル型\'5\'** である'5'を要素に含むことは出来ない．


## 🙍‍♂️ c.
```ts
let k: never = 4 // エラー
```
neverは特殊な型で，決して戻ることのない関数の型を表す（3.2.12より）．
**neverはボトム型であり，neverを他の全ての型に割り当てることは出来るが，逆に，neverに何かの型を割り当てることは出来ない.**
そのため，numberである4は型が異なるため割り当てることは出来ない．


## 🙍‍♂️ d.
```ts
let l: unkown = 4
let m = l * 2 // エラー
```
**unknownは実行時になんにでもなりうる型を示す．**
**していることが安全かどうかをTSに知らせるには，unknownが具体的なサブタイプを取り得ることを示す必要がある．例えば，typeofを使って型を絞り込むような処理を書く．**
lに代入されているリテラル4はnumberであるが，宣言時にunknownとして宣言されており，mの宣言の時点でもunkownである．そのため，numberに許された乗算をunkownは行うことが出来ない．


※ 各型については該当の節を見よう！